## Обзор мьютексов

Рассмотрим простой пример: несколько потоков обращаются к одной общей переменной. Часть потоков 
эту переменную увеличивают (plus потоки), а часть уменьшают на единицу (minus потоки). Число plus и minus 
потоков равно. Таким образом, мы ожидаем, что к концу работы программы значение исходной переменной будет прежним.

Если выполнить код, то он будет возвращать различные значения. Чаще всего они не будут равны нулю. Разберёмся, почему так происходит.
Рассмотрим код функций, которые выполняются в отдельных потоках



Во-первых, у нас имеется локальная переменная local. Во вторых, используется тяжёлая и медленная функция printf. В тот момент, когда мы 
присваиваем локальной переменной значение counter, другой поток может в то же самое время взять это значение и поменять.

Для простоты рассмотрим 4 потока – два plus и два minus

Это один из возможных сценариев развития событий. Очевидно, что могут быть значения от минус 2 до плюс 2. Какой из них будет выполнен, в общем случае не известно.

Проблема заключается в том, что у нас имеется несинхронизированный доступ к общему ресурсу. Мы бы хотели сделать так, чтобы на время 
работы с ресурсом (всё тело функций minus и plus) к ним имел доступ только один поток, а остальные ждали, пока ресурс освободится.
Это так называемое mutual exclusion – взаимное исключение, случай, когда необходимо удостовериться в том, что два (и более…) 
конкурирующих потока не находятся в критической секции кода одновременно.

В библиотеке pthreads один из методов разрешить эту ситуацию – это мьютексы. Мьютекс – это объект, который может находиться в двух состояниях. Он либо заблокирован (занят, залочен, захвачен) каким-то потоком, либо свободен.
Поток, который захватил мьютекс, работает с участком кода. Остальные потоки, когда достигают мьютекса, ждут его разблокировки. Разблокировать мьютекс может только тот поток, который его захватил. Обычно освобождение занятого мьютекса происходит после исполнения критичного к совместному доступу участка кода.

## Порядок использования мьютексов

Мьютекс – это экземпляр типа pthread_mutex_t. Перед использованием необходимо инициализировать 
мьютекс функцией pthread_mutex_init

где первый аргумент – указатель на мьютекс, а второй – аттрибуты мьютекса. Если указан NULL, то используются атрибуты по умолчанию. 
В случае удачной инициализации мьютекс переходит в состояние «инициализированный и свободный», а функция возвращает 0. 
Повторная инициализация инициализированного мьютекса приводит к неопределённому поведению.

Если мьютекс создан статически и не имеет дополнительных параметров, то он может быть инициализирован с помощью макроса 
PTHREAD_MUTEX_INITIALIZER

После использования мьютекса его необходимо уничтожить с помощью функции

В результате функция возвращает 0 в случае успеха или может возвратить код ошибки.

После создания мьютекса он может быть захвачен с помощью функции

После этого участок кода становится недоступным остальным потокам – их выполнение блокируется до тех пор, пока мьютекс не будет освобождён. Освобождение должен провести поток, заблокировавший мьютекс, вызовом

Перейдём к реализации. Для начала сделаем глобальный объект мьютекс, доступный всем потокам.

Код

Заметьте, при использовании мьютекса исполнение защищённого участка кода происходит последовательно всеми потоками, а не параллельно. Порядок доступа отдельных потоков не определён.
Напишем теперь реализацию, в которой мьютекс будет передаваться в качестве параметра функции. Для начала, определим новый тип данных

И перепишем фунции

Весь код

Хочется обратить внимание, что мьютекс один на всех. Если бы у каждого потока был свой собственный мьютекс, то они бы не блокировали работу друг друга. Например, этот код будет работать неправильно

Остановимся подробнее на функциях для работы с мьютексами

Функция может упасть с ошибкой

pthread_mutex_destroy  может вернуть следующие ошибки

pthread_nutex_lock возвращает ошибки

pthread_mutex_lock и pthread_mutex_unlock могут вылететь с ошибками

![mail.png](../images/mail.png)

