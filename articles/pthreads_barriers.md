## Барьер

Барьер – это механизм синхронизации, который позволяет приостановить выполнение потоков у некоторой точки программы до тех пор, пока все потоки 
не дойдут до этого места, и только затем продолжить выполнение дальше.

В отличие от join-а, где мы ожидаем завершения выполнения потока, при использовании барьеров мы ожидаем встречи (рандеву, rendezvous) этих потоков в определённой точке. 
Мы определяем количество потоков, которые должны прибыть к этой точке, блокируем их там, а когда набирается нужное число потоков, разблокируем их все, позволяя работать дальше.

Для создания барьера необходимо создать переменную типа pthread_barrier_t.

Инициализация барьера происходит с помощью функции

Здесь первый аргумент – это указатель на нашу переменную – барьер. Вторая переменная – атрибуты барьера (если их нет, то пишем NULL), последний аргумент – число потоков, которые должны вызвать pthread_barrier_wait, чтобы преодолеть (разблокировать) барьер.
Функция может возвращать ошибки

Кроме того, она обязательно возвратит ошибку, если

pthread_barrier_init выделяет нужные для работы барьера ресурсы, поэтому необходимо очищать их после использования с помощью функции

В случае удачного завершения, как обычно, функция возвращает 0. Возможны следующие ошибки

Собственно синхронизация осуществляется с помощью функции

Поток, которые вызывает функцию pthread_barrier_wait блокируется в месте вызова, до тех пор, пока количество потоков, вызвавших pthread_barrier_wait не станет равным значению count, которое было задано при инициализации этого барьера.

В случае вызова функция возвращает значение PTHREAD_BARRIER_SERIAL_THREAD для произвольного синхронизированного потока, и 0 для всех остальных. Функция возвратит

Если функция pthread_barrier_wait возвращает значение PTHREAD_BARRIER_SERIAL_THREAD, это значит, что барьер может быть уничтожен. То есть, нельзя просто так уничтожать 
барьер в каком-то из потоков, так как порядок завершения потоков не детерминирован.

## Примеры

Пример из предыдущей главы. Задача - вывести в четыре потока четыре строки. Только вместо join-ов теперь будем использовать барьеры. Барьер
для нашей программы может быть глобальной переменной

Внимательно смотрим на функцию. Раньше она выглядела так

В случае, если передавался невалидный аргумент, функция возвращала значение. pthread_join дожидался завершения процесса и
синхронизировал работу. В нашем случае с барьерами мы не можем просто выйти из функции: обязательно должна быть вызвана функция
pthread_barrier_wait, иначе все остальные потоки заблокируются и барьер никогда не преодолеется.

Значение count при инициализации барьера равно NUM_THREADS + 1, потому что функция main, внутри которой порождаются потоки,
сама выполняется в своём потоке.

Глобальные переменные это почти всегда плохо. Будем передавать барьер всем потокам вместе с аргументами. Для этого изменим структуру
someArgs_tag:

ЗАМЕЧАНИЕ: Всё, написаное выше, работает по случайности. В чём же проблема? Проблема заключается в том, что операции pthread_barrier_wait и pthread_barrier_destroy
не являются атомарными. То есть, пока один поток выполняет wait, другой в это время может выполнить свой wait, получить PTHREAD_BARRIER_SERIAL_THREAD и начать уничтожать
барьер. Другой поток, который ещё выполняет wait, не получит валидного барьера (а может быть и получит, в спецификации сказано, что состояние барьера 
после уничтожения без инициализации не определено) и выпадет с ошибкой типа "нарушение прав доступа при чтении по адресу 0xFEEEFEEE".

Решение - явно собрать все потоки, и только потом уничтожить барьер.

Напишем функцию seqMap, которая применяет к каждому элементу массива функцию. В качестве аргументов будем передавать указатель типа void (массив неопределённого типа),
число элементов, размер одного элемента массива и указатель но функцию, которая будет применяться к аргументам. Код должен быть известен из темы об указателях на функции.

Задача: ускорить выполнение этой функции, путём распараллеливания вычислений. В нашем примере функция применяется к каждому элементу массива. Все
элементы точно не зависят друг от друга. То есть, можно разбить массив на участки, каждый из которых будет обрабатываться своим потоком.

Чтобы поток мог обрабатывать свой участок массива, он должен получить указатель на этот массив, начальный и конечный элементы, а также размер элемента массива
и указатель на функцию. Кроме того, будем передавать указатель на барьер.

Далее нужно описать функцию, которая будет работать в потоке и обрабатывать наш подмассив:

Эта функция будет выполняться в своём потоке. Теперь нужно описать функцию, которая будет создавать потоки и распределять по ним нагрузку.
Если нужно обработать, скажем, 10 элементов в 3 потока, то каждый из потоков должен получить подмассив размером 10/3 = 3 элемента, и один
из потоков должен будет вдобавок обработать ещё 10 % 3 = 1 элемент.
Наша функция будет получать указатель на массив, размер массива, размер элемента, функцию и число потоков. Число потоков обязательно должно быть меньше числа 
элементов массива.

Теперь осталось протестировать. Будет два теста: одан маленький, без измерения времени работы, второй большой. Для тестирования зададим несколько функций обработчиков..

Заметьте, последняя функция специально такая сложная, чтобы повысить время выполнения.

Замечания. Во-первых, массив для тестирования создаётся динамически. Если делать локальную переменную, то будет переполнение стека,
так как массив большой. Второе: мы используем типы данных и функции, специфичные для Windows, поэтому нужно будет подключить
библиотеку windows.h.

Запустите программу, откройте диспетчер задач и посмотрите на загрузку процессора. На моём двухядерной процессоре (Intel Core Duo T6600), при работе в два потока 
время выполнения параллельного алгоритма примерно в два раза меньше, чем последовательного. Нагрузка на процессор для однопоточного алгоритма
соответственно 50%, многопоточного 100%.
Для четырёхядерного процессора Intel i5 2310 время выполнения в 4 потока, как это ни удивительно, в 4 раза быстрее, чем однопоточный вариант. Нагрузка на процессор повышается
с 25% до 100%.

Код программы

![mail.png](../images/mail.png)

