## 1. Выделение памяти с явным сохранением размера области.

Когда мы работаем с массивом, то необходимо хранить его размер. Для этого нужно постоянно носить с собой переменную, 
которую нужно передавать в функции или возвращать из функции. Способ реализации функции malloc не определён в документации языка, известно только, что в большинстве 
случаев выделенный участок памяти начинается с метаданных, которые хранят размер области. В различных компиляторах реализованы свои функции, которые могут разбирать 
метаданные и возвращать размер области памяти.

Реализуем функцию  malloc, которая будет явно сохранять размер участка памяти и не будет зависеть от реализации компилятора. Для этого, в начале массива будет сохранять его 
размер в структуре _METADATA_.

Структура содержит всего одно поле – размер size типа size_t. В будущем, если понадобится, без труда можно будет добавить новые поля.
Теперь – функция my_malloc. Она получает размер участка памяти и возвращает указатель на выделенный участок.

1. Выделяем память. Её должно быть на sizeof(_METADATA_) байт больше, чтобы разместить заголовок.

2. Если произошла ошибка и malloc вернула нулевой указатель, то выходим из функции

3. Теперь выделенную область кастуем до структуры _METADATA_ и записываем туда размер

4. Возвращаем указатель со сдвигом на sizeof(_METADATA_), таким образом, он будет иметь размер size

(char*) нужно для того, чтобы прибавить к указателю неопределённого типа число байт, равное размеру _METADATA_.

Функция my_free должна освобождать участок памяти, выделенный функцией my_malloc. Для этого необходимо сдвинуть указатель на размер структуры с метаданными.

Функция get_size принимает указатель, полученный от функции my_malloc и читает размер массива из заголовка. Для этого сдвигаемся к началу области, кастуем её до _METADATA_ и обращаемся к полю size

Функция realloc похожа на malloc. Выделяем память под новый массив размера большего на sizeof(_METADATA_). Заносим в заголовок новый размер.

Проблемы возникают с функцией calloc. Так как она принимает размер массива и размер его элементов, то размер нашего заголовка может быть не кратен размеру элемента. Будет выделять память функцией malloc, а затем функцией memset заполнять выделенную область нулями.

Теперь прикроем стандартные функции макросами

Соберём всё вместе с примерами

## 2. Простой пул памяти.

Уже оговаривалось ранее, что частое выделение памяти под множество мелких объектов, а также изменение размера выделенной области памяти замедляет 
работу и приводит к фрагментации памяти. Создадим просто пул памяти – заранее зарезервированную область памяти, которую будем раздавать. Для простоты сделаем пул глобальной 
переменной.

Здесь mempool – это наш пул, двумерный массив. msize – число строк, соответствует числу блоков памяти, размер которых задаётся пользователем при создании, 
checkbox – массива флагов. Длина массива флагов msize. Если i-й флаг поднят, то i-й блок памяти выделен.

Как это работает:

![mail.png](../images/mail.png)

