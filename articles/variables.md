## Переменные

Переменные используются для хранения значений (sic!).
Переменная характеризуется типом и именем. Начнём с имени. В си переменная может начинаться с подчерка или буквы, но не с числа. Переменная может включать в себя символы английского алфавита, цифры и знак подчёркивания. Переменная не должна совпадать с ключевыми словами (это специальные слова, которые используются в качестве управляющих конструкций, для определения типов и т.п.)

Например, правильные идентификаторы
a, _, _1_, Sarkasm, a_long_variable, aLongVariable, var19, defaultX, char_type
неверные
1a, $value, a-long-value, short

Си - регистрозависимый язык. Переменные с именами a и A, или end и END, или perfectDark и PerfectDarK – это различные переменные.

## Типы переменных

Тип переменной определяет



Теперь давайте определим максимальное и минимальное число, которое может хранить переменная каждого из типов. Числа могут быть как положительными, так и отрицательными. Отрицательные числа используют один бит для хранения знака. Иногда знак необходим (например, храним счёт в банке, температуру, координату и т.д.), а иногда в нём нет необходимости (вес, размер массива, возраст человека и т.д.). Для этого в си используется модификатор типа signed и unsigned.

unsigned char - все 8 бит под число, итого имеем набор чисел от 00000000 до 11111111 в двоичном виде, то есть от 0 до 255
signed char от -128 до 128.

В си переменные по умолчанию со знаком. Поэтому запись char и signed char эквивалентны.

## sizeof

В си есть оператор, который позволяет получить размер переменной в байтах. 
sizeof переменная, или sizeof(переменная) или sizeof(тип). Это именно оператор, потому что функция не имеет возможности получить информацию о размере типов
во время выполнения приложения.
Напишем небольшую программу чтобы удостовериться в размерах переменных.

(Я думаю ясно, что переменные могут иметь любое валидное имя). Эту программу можно было написать и проще

В си один и тот же тип может иметь несколько названий
short === short int
long === long int
long long === long long int
unsigned int === unsigned

## Типы с плавающей точкой

## Переполнение переменных

Си не следит за переполнением переменных. Это значит, что постоянно увеличивая значение, скажем, переменной типа int в конце концов мы "сбросим значение"

Вообще, поведение при переполнении переменной определено только для типа unsigned: Беззнаковое целое сбросит значение.
Для остальных типов может произойти что угодно, и если вам необходимо следить за переполнением, делайте это вручную, проверяя аргументы,
либо используйте иные способы, зависящие от компилятора и архитектуры процессора.

## Постфиксное обозначение типа

При работе с числами можно с помощью литер в конце числа явно указывать его тип, например

Следующий код, однако, не будет приводить к ошибкам, потому что происходит неявное преобразование типа

## Шестнадцатеричный и восьмеричный формат

Во время работы с числами можно использовать шестнадцатеричный и восьмеричный формат представления.
Числа в шестнадцатиричной системе счисления начинаются с 0x, в восьмеричной системе с нуля. Соответственно, если число начинается
с нуля, то в нём не должно быть цифр выше 7:

## Экспоненциальная форма представления чисел

Экспоненциальной формой представления числа называют представление числа в виде

	
		M
		e
		±
		p
	

, где M - мантиса числа, p - степень десяти. При этом у мантисы должен быть один ненулевой знак перед десятичной запятой.
Например 1.25 === 1.25e0, 123.5 === 1.235e2, 0.0002341 === 2.341e-4 и т.д.
Представления 3.2435e7 эквивалентно 3.2435e+7
Существеут и другое представление ("инженерное"), в котором степень должна быть кратной тройке.
Например 1.25 === 1.25e0, 123.5 === 123.5e0, 0.0002341 === 234.1e-6, 0.25873256 === 258.73256e-3 и т.д.

## Объявление переменных

В си переменные объявляются всегда в начале блока (блок - участок кода ,ограниченный фигурными скобками)

При объявлении переменной пишется её тип и имя.

Можно объявить несколько переменных одного типа, разделив имена запятой

Например

Здесь объявлены переменные a и b внутри функции main, и  переменная z внутри тела цикла.
Следующий код вызовет ошибку компиляции

Это связано с тем, что объявление переменной стоит после оператора присваивания. 
При объявлении переменных можно их сразу инициализировать.
int i = 0;
При этом инициализация при объявлении переменной не считается за отдельный оператор, поэтому следующий код будет работать

## Начальное значение переменной

Очень важно запомнить, что переменные в си не инициализируются по умолчанию нулями, как во многих других языках программирования. 
После объявления переменной в ней хранится "мусор" - случайное значение, которое осталось в той области памяти, которая была выделена под переменную.
Это связано, в первую очередь, с оптимизацией работы программы: если нет необходимости в инициализации, то незачем тратить ресурсы
для записи нулей (замечание: глобальные переменные инициализируются нулями, почему так, читайте в этой статье).

Если выполнять эту программу на VC, то во время выполнения вылетит предупреждение
Run-Time Check Failure #3 - The variable 'i' is being used without being initialized.
Если нажать "Продолжить", то программа выведет "мусор". В многих других компиляторах при выполнении программы не будет предупреждения.

## Область видимости переменной

Переменные бывают локальными (объявленными внутри какой-нибудь функции) и глобальными. Глобальная переменная видна всем функциям, объявленным в данном файле. 
Локальная переменная ограничена своей областью видимости.
Когда я говорю, что переменная "видна в каком-то месте", это означает, что в этом месте она определена и её можно использовать. 
Например, рассмотрим программу, в которой есть глобальная переменная

Будет выведено
foo: 100
bar: 333
Здесь глобальная переменная global видна всем функциям. Но аргумент функции затирает глобальную переменную, поэтому при передаче аргумента 333 выводится локальное значение 333.

Вот другой пример

Программа выведет 555. Также, как и в прошлом случае, локальная переменная "важнее".
Переменная, объявленная в некоторой области видимости не видна вне её, например

Этот пример не скомпилируется, потому что переменная y существует только внутри своего блока.

Вот ещё пример, когда переменные, объявленные внутри блока перекрывают друг друга

Программа выведет
30
20
10
Глобальных переменных необходимо избегать. Очень часто можно услышать такое. Давайте попытаемся разобраться, почему. 
В ваших простых проектах глобальные переменные выглядят вполне нормально. Но представьте, что у вас приложение, которое

Во-первых, глобальная переменная, если она видна всем, может быть изменена любой частью программы. 
Вы изменили глобальную переменную, хотите её записать, а другая часть программы уже перезаписала в неё другое значение 
(на самом деле это целый класс проблем, которые возникают в многопоточной среде). Во-вторых, при больших размерах проекта не уследить, 
кто и когда насоздавал глобальных переменных. В приведённых выше примерах видно, как переменные могут перекрывать друг друга, то же произойдёт и в крупном проекте.

Безусловно, есть ситуации, когда глобальные переменные упрощают программу, но такие ситуации случаются не часто и не в ваших домашних заданиях, так что НЕ СОЗДАВАЙТЕ ГЛОБАЛЬНЫХ ПЕРЕМЕННЫХ!

Переменные могут быть не только целочисленными и с плавающей точкой. Существует множество других типов, которые мы будем изучать в дальнейшем.

![mail.png](../images/mail.png)

