## Введение. Циклы с предусловием.

При решении практических задач постоянно возникает необходимость в повторении действия заданное количество раз, или до достижения какого-либо условия. Например, вывести список всех пользователей, замостить плоскость текстурой, провести вычисления над каждым элементом массива данных и т.п.
В си для этих целей используются три вида циклов: с предусловием, постусловием и цикл for со счётчиком (хотя, это условное название, потому что счётчика может и не быть).

Любой цикл состоит из тела и проверки условия, при котором этот цикл должен быть прекращён. Тело цикла - это тот набор инструкций, который необходимо повторять. Каждое повторение цикла называют итерацией.

Рассмотрим цикл с предусловием.

Этот цикл выполняется до тех пор, пока истинно условие, заданное после ключевого слова while.
Тело цикла - это две строки, одна выводит число, вторая изменяет его.
Очевидно, что этот цикл будет выполнен 10 раз и выведет на экран
0
1
2
3
и так далее до 9.

Очень важно, чтобы условие выхода из цикла когда-нибудь выполнилось, иначе произойдёт зацикливание, и программа не завершится.
К примеру

В этом цикле не изменяется переменная i, которая служит для определения условия останова, поэтому цикл не завершится.

В этой программе цикл, конечно, завершится, но из-за неправильного действия он будет выполнен гораздо больше 10 раз. Так как си не следит за переполнением переменной, нужно будет ждать, пока переменная переполнится и станет меньше нуля.

У этого примера неопределённое поведение. Так как переменная i заранее не инициализирована, то она хранит мусор, заранее неизвестное значение. При различном содержимом переменной i будет меняться поведение.

Если тело цикла while содержит один оператор, то фигурные скобки можно опустить.

Здесь мы инкрементируем переменную i при вызове функции printf.
Следует избегать такого стиля кодирования. Отсутствие фигурных скобок, особенно в начале обучения, может приводить к ошибкам. Кроме того, код читается хуже, да и лишние скобки не сильно раздувают листинги.

## Циклы с постусловием.

Цикл с постусловием отличается от цикла while тем, что условие в нём проверяется после выполнения цикла, то есть этот цикл будет повторён как минимум один раз (в отличие от цикла while, который может вообще не выполняться). Синтаксис цикла

Предыдущий пример с использованием цикла do будет выглядеть как

Давайте рассмотрим пример использования цикла с постусловием и предусловием. Пусть нам необходимо проинтегрировать функцию.

![c_loop_integral.png](../images/c_loop_integral.png)

Интеграл - это сумма бесконечно малых. Мы можем представить интеграл как сумму, а бесконечно малые значения просто заменить маленькими значениями.

Из формулы видно, что мы на самом деле разбили площадь под графиком на множество прямоугольников, где высота прямоугольника - это значение функции в точке, а ширина - это наш шаг. Сложив площади всех прямоугольников, мы тем самым получим значение интеграла с некоторой погрешностью.

![c_loop_rectangles_left.png](../images/c_loop_rectangles_left.png)

Пусть искомой функцией будет 

      
       
       x
       2
       
      
.
Нам понадобятся следующие переменные. Во-первых, аккумулятор sum для хранения интеграла. Во-вторых, левая и правая границы a и b, в третьих - шаг h. Также нам понадобится текущее значение аргумента функции x.

Для нахождения интеграла необходимо пройти от a до b с некоторым шагом h, и прибавлять к сумме площадь прямоугольника со сторонами f(x) и h.

Программа выводит 0.328.

Решение

Если посмотреть на график, то видно, что каждый раз мы находим значение функции в левой точке. Поэтому такой метод численного интегрирования называют методом левых прямоугольников. Аналогично, можно взять правое значение. Тогда это будет метод правых прямоугольников.

![c_loop_rectangles_right.png](../images/c_loop_rectangles_right.png)

Сумма в этом случае будет равна 0.338. Метод левых и правых прямоугольников не очень точен. Мы фактически аппроксимировали (приблизили) гладкий график монотонно возрастающей функции гистограммой.
Если немного подумать, то аппроксимацию можно проводить не только суммируя прямоугольники, но и суммируя трапеции.

![c_loop_integral_trapezium.png](../images/c_loop_integral_trapezium.png)

Приближение с помощью трапеций на самом деле является кусочной аппроксимацией кривыми первого порядка (ax+b). Мы соединяем точки на графике с помощью отрезков. Можно усложнить, 
соединяя точки не отрезками, а кусками параболы, тогда это будет метод Симпсона. Если ещё усложнить, то придём к сплайн интерполяции, но это уже другой, очень долгий разговор.

Вернёмся к нашим баранам. Рассмотрим 4 цикла.

Если выполнить эти примеры, то будет видно, что циклы выполняются от двух, до четырёх раз. На это стоит обратить внимание, потому что неверное изменение счётчика цикла часто приводит к ошибкам.

Часто случается, что нам необходимо выйти из цикла, не дожидаясь, пока будет поднят какой-то флаг, или значение переменной изменится. Для этих целей служит оператор break, который заставляет программу выйти из текущего цикла.

Давайте решим простую задачу. Пользователь вводит числа до тех пор, пока не будет введено число 0, после этого выводит самое большое из введённых.
Здесь есть одна загвоздка. Сколько чисел введёт пользователь не известно. Поэтому мы создадим бесконечный цикл, а выходить из него будем с помощью оператора break. Внутри цикла мы будем получать от пользователя данные и выбирать максимальное число.

Напомню, что в си нет специального булевого типа. Вместо него используются числа. Ноль - это ложь, все остальные значения – это истина.
Цикл while(1) будет выполняться бесконечно. Единственной точкой выхода из него является условие

В этом случае мы выходим из цикла с помощью break;
Для начала в качестве максимального задаём 0. Пользователь вводит число, после чего мы проверяем, ноль это или нет. Если это не ноль, то сравниваем его с текущим максимальным.

Бесконечные циклы используются достаточно часто, так как не всегда заранее известны входные данные, либо они могут меняться во время работы программы.

Когда нам необходимо пропустить тело цикла, но при этом продолжить выполнение цикла, используется оператор continue. Простой пример: пользователь вводит десять чисел. Найти сумму всех положительных чисел, которые он ввёл.

Пример кажется несколько притянутым за уши, хотя в общем он отражает смысл оператора continue. В этом примере переменная positiveCnt является счётчиком положительных чисел, sum сумма, а input - временная переменная для ввода чисел.

Вот ещё один пример. Необходимо, чтобы пользователь ввёл целое число больше нуля и меньше 100. Пока необходимое число не будет введено,  программа будет продолжать опрос.

## Цикл for

Одним из самых используемых является цикл со счётчиком for. Его синтаксис

Например, выведем квадраты первых ста чисел.

Одним из замечательных моментов цикла for является то, что он может работать не только с целыми числами.

Этот цикл выведет числа от 5.3 до 0.1. 
Цикл for может не иметь некоторых "блоков" кода, например, может отсутствовать инициализация, проверка (тогда цикл становится бесконечным) или изменение счётчика. 
Вот пример с интегралом, реализованный с применением счётчика for

Давайте рассмотрим кусок кода

Его можно изменить так

Более того, используя оператор break, можно убрать условие и написать

или так

кроме того, используя оператор ",", можно часть действий перенести

ЗАМЕЧАНИЕ: несмотря на то, что так можно делать, пожалуйста, не делайте так! Это ухудшает читаемость кода и приводит к трудноуловимым ошибкам.

Давайте решим какую-нибудь практическую задачу посложнее.
Пусть у нас имеется функция f(x). Найдём максимум её производной на отрезке.
Как найти производную функции численно? Очевидно, по определению). Производная функции в точке - это тангенс угла наклона касательной.

![c_loop_partials.png](../images/c_loop_partials.png)

Возьмём точку на кривой с координатами (x; f(x)), сдвинемся на шаг h вперёд, получим точку (x+h, f(x+h)), тогда производная будет

То есть, отношение малого приращения функции к малому приращению аргумента.
Внимательный читатель может задать вопрос, почему мы двигаемся вперёд по функции, а не назад. Ну пойдёмте назад

Возьмём среднее от этих двух значений, получим

В общем-то теперь задача становится тривиальной: идём от точки a до точки b и находим минимальное значение производной, а также точку, в которой производная принимает это значение.
Для решения нам понадобятся, как и в задаче с интегралом, переменные для границ области поиска a и b, текущее значение x и шаг h. 
Кроме того, необходимо максимальное значение maxVal и координата maxX этого максимального значения.
Для работы возьмём функцию 

	
		x
		•
        sin
        &ApplyFunction;
		x

На выходе программа выдаёт
max value = 1.391 at 1.077

![c_loop_derivative.png](../images/c_loop_derivative.png)

Численное решение даёт такие же (с точностью до погрешности) результаты, что и наша программа.

## Вложенные циклы

Рассмотрим пример, где циклы вложены друг в друга. Выведем таблицу умножения.

В этом примере в первый цикл по переменной i вложен второй цикл по переменной j. Последовательность действий такая: сначала мы входим в цикл по i, после этого для текущего i 10 раз подряд осуществляется вывод чисел. После этого необходимо перейти на новую строку.
Теперь давайте выведем только элементы под главной диагональю

Как вы видите, оператор break позволяет выйти только из текущего цикла. Этот пример может быть переписан следующим образом

В данном случае мы используем во вложенном цикле счётчик первого цикла.

![mail.png](../images/mail.png)

