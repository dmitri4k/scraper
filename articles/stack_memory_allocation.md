## Массивы произвольной длинны и динамическое выделение памяти на стеке

В С90 нет возможности создать массив произвольной длины. Размер массива должен быть известен на момент компиляции

В стандарте С99 появилась возможность создавать массивы, размер которых не известен на момент компиляции. Например, можно передать функции размер массива и создать временный массив

Массивы произвольной длины нельзя инициализировать при создании. Например, следующий код не скомпилируется

Сделано это (по-видимому) из соображений безопасности. Если необходимо заполнить массив значениями, то это можно сделать поэлементно, либо, например, с помощью функции memset.

Тем не менее, VSE не поддерживает это нововведение и не собирается в дальнейшем.

Каким образом можно динамически создать массив произвольного размера на стеке? Очевидно, нам нужна такая функция, которая бы позволяла выделять память на стеке. Эта функция называется alloca, или _alloca и определена в библиотеке malloc.h

(Здесь и далее у нестандартных функций идёт префиксом подчёркивание. В GNU версиях компиляторов его нет). Так как память выделяется на стеке, то нет необходимости её подчищать – после выхода из функции стек будет восстановлен и локальные переменные «уничтожены». К тому же, выделение памяти происходит очень быстро (на несколько порядков быстрее, чем выделение на куче) и не приводит к фрагментации.

Но здесь возникает та же проблема, что и с массивами произвольной длины – если выделить слишком много памяти, то произойдёт переполнение стека.  Функция _alloca, в отличие от 
malloc, не возвращает NULL, если не смогла выделить память, а создаёт структурированное исключение переполнения стека. Например, вызовите

Поэтому предлагают такой способ выделения

Не очень-то красиво. Освобождение памяти происходит только после выхода из функции, а не после выхода за пределы видимости. Функция _alloca была в дальнейшем запрещена и заменена 
на функцию _malloca. Он отличается тем, что сначала пытается выделить место на стеке, а если не смогла этого сделать, то выделяет место на куче, то есть, работает как malloc. 
Однако если память может быть выделена на куче, то её придётся освобождать после себя. Для этого используется функция _freea. Если память была выделена на стеке, то функция 
ничего не делает. Если память была выделена на куче, то _freea освобождает её как стандартная free. Это цена за более безопасное использование.

malloca в случае выделения памяти на куче ведёт себя как и malloc. То есть, если память не удалось выделить на куче, то будет возвращён NULL.

ЗАМЕЧАНИЕ: _malloca будет выделять память на стеке только в релизе. В отладочной версии проекта память всегда выделяется на куче.

![mail.png](../images/mail.png)

