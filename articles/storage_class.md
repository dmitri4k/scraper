В си определено несколько классов памяти для переменных и функций. Они изменяют область видимости переменных и функций, определяют время жизни объекта и расположение в памяти.

## Классы памяти переменных

По умолчанию, локальные переменные имеют класс auto. Такие переменные располагаются на стеке а их область видимости ограничена своим блоком. Запись

идентична

Очевидно, что глобальные переменные не могут быть объявлены как auto, потому что располагаются в data-сегменте.

Следующий класс памяти – register. Когда мы определяем регистровую переменную, то мы просим компилятор, чтобы переменная располагалась в регистре, а не в оперативной памяти. Компилятор может сделать переменную регистровой, если позволяют условия (регистры не заняты, и по мнению компилятора это не приведёт к увеличению издержек). Регистровые переменные определяются с помощью служебного слово register перед типом

Так как регистровая переменная не имеет адреса, то к ней не применима операция взятия адреса, это вызовет ошибку во время компиляции.

Аргументы функции также могут быть заданы как register. Внутри функции они будут вести себя также, как и регистровые переменные.

Следующий класс памяти – статический. Переменные, объявленные как static, хранятся в data или в bss сегменте. Отличительной чертой является то, что время их жизни совпадает с временем жизни приложения, как и у глобальных переменных. Но в отличие от глобальных переменных, область видимости ограничена только блоком, в котором они определены.

В этом примере переменные prevArg и prevAns инициализируются единожды, и не уничтожаются после выхода из функции. Переменная prevArg используется для хранения 
предыдущего аргумента функции, а prevAns для хранения предыдущего результата. Если аргумента функции совпадает с предыдущим, то возвращается ранее вычисленное значение, иначе
оно вычисляется по-новому.

Другой показательный пример – функция-генератор, которая при каждом вызове возвращает новое значение.

Если бы служебное слово static отсутствовало, то каждый раз при вызове функции локальная переменная counter снова создавалась, инициализировалась и уничтожалась после выхода из функции.

Статическая переменная может иметь только константную инициализацию. Например, она не может быть инициализирована вызовом функции.

Переменная, объявленная как static, должна иметь только 
один экземпляр в данной области видимости и вне этой области видимости не видна. Глобальная переменная, объявленная как static, видна только в своём файле.

Напротив, переменная, объявленная как extern может быть использована в других файлах при условии, что она была определена.

## Объявление и определение переменной.

В глобальном контексте переменная сначала требует объявления. Таким образом, компилятор будет знать её имя и тип. Определение
 переменной требует выделения под неё памяти и инициализации.  Посмотрите следующий код. Он абсолютно легален и должен работать по стандарту

Теперь, что будет, если одновременно объявить переменную и инициализировать её. Это определение переменной, которое требует её объявления

Следующая программа не скомпилируется

Это связано с тем, что отсутствует определение переменной. Если определить переменную внутри main, то это будет уже другой экземпляр переменной, которая будет расположена на стеке.
Вообще, при работе с одним файлом использование extern переменных не оправдано. Рассмотрим ситуацию, когда у нас имеются ещё два файла – заголовочный File1.h и File1.c. В заголовочном файле объявим extern переменную Global

в файле исходного кода определим её

После подключения файла File1.h можно использовать эту переменную в файле main.c, при этом гарантировано, что существует только один экземпляр этой переменной для всех файлов проекта

Если теперь определим функцию, которая изменяет эту переменную, то все функции из всех файлов будут видеть эти изменения.

File1.h:

File1.c

main.c

Вывод


From main: Global = 567
from File1: Global = 567
changed to 1234
From main: Global = 1234

## Класс памяти для функций

Функции по умолчанию определены как extern, это значит, что они видны всем, кто подключит данный файл. То есть, запись

эквивалентна

Другой класс - static, делает функцию видимой только внутри своего модуля.

Рассмотрим пример – у нас будет, как обычно 2 файла, File1.h и File1.c. В первом определим две функции, одну extern, а вторую static

Fil1.c

Заметьте: мы не сможем вызвать функцию hidden вне файла File1.c, но внутри файла эта функция доступна.

Для функций также, как и для переменных, различают объявление и определение. Объявление обычно прячут в заголовочный файл, также как и объявление переменных. Определения 
находятся в си файле.

![mail.png](../images/mail.png)

