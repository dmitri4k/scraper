## Определение макросов

Перед тем как программа будет скомпилирована (или не будет, если найдены ошибки), текст программы обрабатывается препроцессором. 
Препроцессор позволяет изменять текст программы, используя специальные директивы. 

Директива #define определяет новый макрос. Макрос, или макроподстановка, будет заменена в коде программы своим телом. Например, 
мы часто пользовались макросом

и после этого использовали SIZE вместо размера массива.
Макрос может иметь любое допустимое имя и обычно его пишут прописными буквами для того, чтобы отличать от переменных и констант.

Макрос подставляется непосредственно в текст вашей программы. То есть, если у вас был код

то он будет заменён на код

Иными словами, макроподстановка - это просто подмена одного куска текста на другой.

Макросы могут иметь аргументы.

Например

Несмотря на то, что этот код работает, в нём есть ошибки. Макроподстановка – это именно подстановка:

Будет выведено

max number is 11
a = 11
b = 12

Это связано с тем, что код будет подменён следующим образом

("max number is %d\n", a++ > b++ ? a++: b++);

В данном случае возвращаемое значение будет ещё раз инкрементировано. Теперь рассмотрим макрос

С одной стороны, этот макрос должен делать программу быстрее, если заменить им вызов функции. Но на деле работать он будет медленнее. Макрос развернётся в следующий код


4,18879020 * (halfA + halfB) * (halfA + halfB) * (halfA + halfB)

итого, три раза будет вызвано сложение. Вот ещё пример ошибки

В данном случае будет выведено 19 вместо 45, так как макрос будет раскрыт в выражение

2 + 3 * 4 + 5 == 2 + 12 + 5 == 19

Решением будет следующий макрос:

И ещё одна ошибка, которая также встречается очень часто. Давайте напишем макрос, который будет выводить на печать массив. Мы воспользуемся им в сортировке пузырьком, чтобы видеть, как изменяется массив во время сортировки.

Этот пример работать не будет. Дело в том, что он использует переменную i, которая уже занята. Для корректной работы необходимо локализовать переменную. 
Для этого тело макроса нужно обернуть фигурными скобками и внутри задать переменную

Да, кстати, заметьте, как пишется многострочный макрос - каждая строка оканчивается обратным слешем.


Поэтому, при работе с параметризованными макросами

Важно отметить ещё одну особенность языка. Строки в си ограничены двойными кавычками, но их можно конкатенировать просто
написав рядом, например

Таким образом, можно объявлять макросы и использовать их следующим образом

## Условные конструкции

Такая конструкция будет выполнять первую ветвь, если определён макрос с заданным именем. Например, таким образом можно создавать макрос, который будет выводить 
отладочную информацию.

Если теперь ввести 12, то программа выведет

step 1 finished
step 2 finished
66

Если же удалить строку #define DEBUG, то будет выведено только
66
потому что сработает вторая ветвь условия и info("строка") будет заменено на пустую строку.

Изменим макрос следующим образом

Теперь вместо ifdef мы использовали директиву if, она в зависимости от условия выбирает первую или вторую ветвь.
Также мы использовали макрос ON и OFF, а в дальнейшем использовали этот макрос в другом макросе. Это возможно, потому что первый макрос заменяется далее по ходу 
программы на своё тело. Так что первый макрос изменяет остальные макросы, а потом они уже вставляются далее в программу.

В этом примере, для того, чтобы отключить вывод сообщений, достаточно поменять строчку

на

Кроме директивы
 #ifdef
используется директива 
#ifndef  (if not defined), он работает также, но первая ветвь работает только в случае, если макрос не определён.

Также, как и с условными конструкциями, макрос может и не содержать ветви else.

## Предопределённые макросы.

В стандарте си заранее определено несколько полезных макросов. Все их рассматривать мы не будем, только часть из них.

## Использование препроцессора для инициализации объектов

В си директива include вставляет кусок кода в то место, где она указана. Это значит, что можно использовать директиву для начальной инициализации объектов, если, например, они
слишком большие. Представленный ниже код валиден.

## Макросы с переменным числом параметров

В С11 определён новый тип макросов – макросы с переменным числом параметров. Определяется он похоже на функции с переменным числом 
параметров. Обращение к параметрам происходит через макрос __VA_ARGS__. __VA_ARGS__  заменяется на переданные аргументы. Пример: имеется функция, собирающая односвязный список 
из массива.

Необходимо написать макрос, который бы собрал список, при этом количество параметров можно было изменять.

Функция fromArray получает три аргумента – указатель на узел, массив и его размер. Мы хотим избавиться от размера и массива. Тем не менее, всё равно придётся передавать тип массива, чтобы автоматически можно было изменять его размер.

Макрос принимает два обязательных параметра – имя узла и название типа. Оставшихся параметров будет произвольное число, они перечисляются через запятую.

внутри блока (области, ограниченной фигурными скобками) создаём массив и инициализируем его. При этом длина массива определяется автоматически.

Вызываем функцию, передавая ей в качестве аргументов указатель на узел, массив, который мы только что создали и размер. Так как тип массива известен и массив статический, то количество элементов находится элементарно.

Вызов

таким образом, будет трансформирован в

## Стрингизация и конкатенация макросов

Если во время создания макроса появилась необходимость в том, чтобы сделать из макроса строку или соединять макросы в один, то можно
воспользоваться операторами # и ##. Оператор # превращает переданное значение в строку. Оператор ## соединяет элементы макроса. Например, пусть у нас имеется структура,
которая используется для парсинга комманд. Она состоит из строки (имени команды) и самой команды. При этом мы решили, что имя функции должно состоять из имени комманды плюс _command:

Для сокращения кода можно объявить такой макрос

Здесь #NAME превращает переданный параметр в строку, а NAME ## _command конкатенирует параметр с _command. Весь код:

Другой пример - макрос, который выводит на печать макрос.

Этот макрос выведет на печать __somedata

Макросы - опасная штука. В них очень легко можно сделать ошибку, их сложно отлаживать и сопровождать. В этом курсе си, в общем-то, вам они совершенно не нужны 
(но врага надо знать в лицо). В то же время макросы - это мощный инструмент, который позволяет расширить возможности языка. Например, создание кроссплатформенных библиотек, 
или условная компиляция, которая зависит от железа. Или такие изыски, как метод Даффа, позволяющий 
разматывать тело цикла, или реализация сопрограмм Саймоном Тетхемом.

![mail.png](../images/mail.png)

