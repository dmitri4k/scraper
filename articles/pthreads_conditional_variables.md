Поставим задачу. Пусть есть процесс, один или несколько, которые генерируют задачи. Делают они это через неопределённые промежутки времени. И есть один процесс, который обрабатывает эти задачи. Например, есть поток, который занимается рассылкой писем, и несколько потоков, которые кидают сообщения к отправке.
Каким образом реализовать поток, занимающийся обработкой сообщений? С имеющимися у нас инструментами, можно создать бесконечный цикл, который будет через определённые промежутки времени проверять, есть ли данные, которые необходимо обработать, и обрабатывать их. Так как есть общий ресурс (в нашем упрощённом примере это будет массив со счётчиком), то для работы с ним нужно будет вводить мьютекс.



Какие здесь есть проблемы?

Нам бы хотелось, чтобы поток ожидал события, не выполняя лишних действий, пока ему не придёт сообщение. После этого сообщения он начнёт 
работать. Например, поток будет ждать, пока не накопится 10 сообщений. После чего поток producer пошлёт ему сигнал. Consumer 
отработает и опять уйдёт ждать, пока не накопятся сообщения.

Для решения этой задачи можно использовать условную переменную. Условная переменная в Pthreads – это переменная типа pthread_cond_t, 
которая обеспечивает блокирование одного или нескольких потоков до тех пор, пока не придёт сигнал, или не пройдёт максимально 
установленное время ожидания. Условная переменная используется совместно с ассоциированным с ней мьютексом.

Как обычно, для создания условной переменной используется функция

где cond – указатель на переменную типа pthread_cond_t, attr – аттрибуты условной переменной.

Понятно, что во время работы могут всплыть ошибки, например

Для уничтожения условной переменной используется функция

которая выбрасывает ошибки

Для ожидания сигнала можно использовать функцию

которая ждёт неопределённо долго, или функцию

которая ждёт до момента abstime (это абсолютное время, а не относительное!).

Для того, чтобы послать сигнал, используются две функции

разблокирует как минимум один поток, заблокированный переменной cond, и

которая разблокирует все потоки, заблокированные с помощью условной переменной cond.

Обе функции могут возвратить ошибочное значение EINVAL, если аргумент функции не указывает на инициализированную переменную типа pthread_cond_t.

Рассмотрим тот же самый пример, что и выше, только с условной переменной.

Здесь два потока поставщика, каждый принимает в качестве аргумента свой номер, и один поток обработчик. Код довольно простой и не требует дополнительных пояснений.

Теперь попробуем использовать функцию pthread_cond_timedwait. Для этого заменим код функции consumer на следующий:

Напишем теперь более приличный пример. Сделаем очередь сообщений. И несколько потоков, обрабатывающих очередь, и 
несколько потоков, пишущих в очередь. Так как очередь будет общим ресурсом, то запись и чтение из неё должны будут 
синхронизироваться с помощью мьютексов. Потоки обработчики также, как и в прошлом примере, будут ждать, 
пока не накопится нужное число сообщений, либо не пройдёт время для проверки очереди.

Для чистоты избавимся от глобальных переменных, очередь и все примитивы синхронизации будем передавать в аргументах. На примере рассмотрим, как ведёт себя pthread_cond_signal и pthread_cond_broadcast.

Так как задача усложнилась, разобьём решение на несколько файлов. Первым делом определимся с очередью сообщений. Так как нам надо писать в неё, и читать из неё, то ресурс должен быть защищён от многопоточного доступа мьютексом.

Файл queue.h

Здесь всё понятно. Функция вставки элемента в начало очереди, функция удаления с конца и функция 
получения размера. При этом функция вставки возвращает размер очереди после вставки. 
Структура node_tag – это узел двусвязного списка, описанный в queue.c. Сама очередь содержит указатель на голову, последний элемент, 
размер очереди, а также мьютекс, который используется при каждом доступе к функциям pop, push и get_size.

Файл queue.c содержит определения функций

Обращу некоторое внимание на следующие строчки.



Всегда, когда мы покидаем функцию, мьютекс должен быть разблокирован, иначе мы придём либо 
к ситуации, когда все потоки встанут, ожидая мьютекса (который некому будет освободить), либо к ситуации, когда один из потоков попытается завладеть мьютексом, которым он уже владеет. Плохо!

Получение размера очереди должно также происходить внутри защищённой мьютексом области кода.

Наша очередь хранит пустой указатель, поэтому можно, в принципе, хранить там любой объект. Важно только правильным образом управлять памятью.

Теперь объявим новый тип message_t, который будет храниться в очереди. Пока в нём будет только несколько полей для тестирования.

message.h

И message.c

Сообщение состоит из времени создания, текстового сообщения и идентификатора. Например, можно в качестве сообщения посылать имя скрипта на языке lua, а при обработке события вызывать этот скрипт.

Так как мне лень, то всё остальное я опишу в файле main.c

1. Определю такой простой макрос

2. Самое сложное. Объявляю структуру очередь сообщений

Начинаем обсуждать поля.

queue_t queue – собственно, очередь, которую мы описали в queue.c

size_t processed – счётчик того, сколько задач обработано. 
size_t sent – сколько задач поставлено в очередь. Для работы с этими 
счётчиками будем использовать спинлок sent_proc_lock.

Потоки производители и потоки обработчики будут работать бесконечно. Для того, чтобы их остановить, используются переменные флаги 

unsigned char stop_prod;
unsigned char stop_cons;
Для безопасной работы с ними используется спинлок
pthread_spinlock_t *await_lock;

Конечно, для каждого счётчика и для каждого флага можно использовать свой спинлок (и даже лучше…), или мьютекс.

Каждый поток получит указатель на один экземпляр этой структуры. Но кроме неё я буду передавать каждому потоку ещё уникальное имя, чтобы удобнее было следить за их поведением. Для этого объявлю новую структуру

Функция создания arg_t переменной

Ничего нового, просто инициализируем по порядку все поля. Здесь, конечно, опущены все проверки. В пару ей функция уничтожения полей структуры (полей, а не самой структуры)

Функция производитель

Эта функция создаёт новую задачу. В качестве текста сообщения она отправляет строку со случайным числом , это время, 
которое будет спать поток.

Рассмотрим подробнее

Здесь поток проверяет флаг await_lock. Если он установлен (т.е. не равен нулю), то продолжаем работу, иначе выходим из бесконечного цикла.

Здесь мы создаём случайное число в пределах от 0 до 300. Это сколько поток будет спать в мс. Заметьте, что мы используем rand_s функцию. rand является не потокобезопасной и будет возвращать для всех потоков одно и то же число.

Здесь мы просто увеличиваем счётчик поставленных в очередь задач.

Также хочу заметить, что спит поток уже после разблокировки мьютекса, защищающего условную переменную, иначе все остальные потоки будут его ждать.

Бродкаст произойдёт после того, как размер очереди превысит THRESHOLD.

Так как новое сообщение функцией create_message выделяет память, то её надо будет очищать

Теперь функция, которая обрабатывает сообщения.

Логика следующая. Функция ждёт, пока не придёт сообщение, либо пока не пройдёт больше трёх секунд от момента создания.

это позволяет решить важную проблему. Если мы отключим производителей, то в очереди останутся ещё задачи. По прошествии 3-х секунд все сообщения будут обработаны, даже если некому послать бродкаст. Именно по этой причине проверять, заблокировано ли выполнение, мы будем в конце, после обработки сообщений.

Здесь вызов функции get_size произойдёт только после того, как проверено, что флаг остановки потока поднят. Т.е. не более одного раза, непосредственно перед остановкой.

Очищение памяти из-под сообщения

и неизвестная вам функция

печатающая в буфер форматированное время.

Собственно, тестирование

Код программы

В качестве задания добавьте дополнительные спинлоки для каждого флага остановки потоков и выделите все функции в отдельный файл,
оставив только функцию main.

![mail.png](../images/mail.png)

