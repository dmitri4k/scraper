Для того, чтобы разобраться с библиотекой, начнём с файловой системы. Научимся 
открывать, читать и писать в файлы.



Сначала мы объявляем переменную loop, которая будет нашим главным циклом 
оповещения о событиях. Главный цикл собирает события и управляет их вызовом.

Библиотека основана на «запросах» разных типов, которые после своего завершения могут вызвать 
следующую функцию обратного вызова, которую мы будем называть дальше callback.

Запросы выполняются асинхронно, без ожидания завершения другими вызовами (сразу чтоит оговорить, что не все запросы асинхронны, и не при любых аргументах).
Для начала объявим два запроса для файловой системы – переменные типа uv_fs_t

а также объявим две функции колбэка – open_cb и close_cb. Эти функции будут вызываться ПОСЛЕ того, как выполнятся 
соответствующие функции. оpen_cb после вызова функции, открывающей файл, и close_cb после того, 
как выполнится функция закрытия файла.

Теперь заходим внутрь main. Сначала инициализируем наш event loop:

после чего помещаем в очередь операцию, открывающую файл

Вызов возвращает код ошибки меньше нуля, если функция не могла быть выполнена. Для того, чтобы получить текстовое 
сообщение ошибки, используется функция

Результатом операции uv_fs_open будет дескриптор файла. Это значение возвращается не непосредственно, 
а как поле result аргумента функции open_cb!

Вызов

Запускает наш event loop.

После запуска происходит вызов функции, открывающей файл. После того, как файл открыт, будет вызван колбэк, переданный в 
качестве аргумента, то есть open_cb. Посмотрим ещё раз

Первый аргумент – цикл событий, второй – запрос к файловой системе, третий – имя файла, затем идёт флаги доступа и тип 
доступа. Последним аргументом будет функция обратного вызова, которая автоматически сработает после завершения работы 
uv_fs_open и получит в качестве аргумента uv_fs_t – наш запрос, который будет содержать необходимые данные для работы 
с файлом.

Теперь собственно колбэки.

open_cb – вызывается после открытия файла. Внутри себя она проверяет результат. Если тот меньше нуля, то выводит ошибку.
Обязательным является вызов

Эта функция очищает выделенную по необходимости память.
После этого в очередь ставится новая задача – закрыть файл. Всё аналогично вызову открытия файла

только здесь свой вызов close_req и свой колбэк close_cb. Работа колбэка close_cb тривиальна.

Это самый простой пример. Теперь давайте прочитаем из файла. Заранее укажу, что размер файла меньше, 
чем размер буфера. Как прочитать большой файл выясним позднее.

Для чтения будет использоваться функция

Эта функция возвращает код ошибки, а в поле result запроса возвращает число удачно считанных байт данных.

Первый аргумент – loop, как и раньше, главный цикл, req – запрос, bufs – массив буферов, типа uv_buf_t, nbufs – число буферов, 
offset – сдвиг в файле (если мы читаем не с начала, например), cb – колбэк.

Вот сама программа

Разберём её подробнее. Особое внимание надо обратить на буфер, который используется для чтения из файла.

Здесь сразу стоит указать – функция uv_fs_read принимает в качестве аргумента массив буферов, но мы можем передавать 
один элемент (точнее указатель на него), так как это не будет отличаться от передачи массива из одного элемента (вот почему).

Структура uv_buf_t владеет полем base, которое необходимо инициализировать отдельно. Поле base – собственно массив, который 
и хранит считанные данные.

Для сборки структуры используется функция

Важно помнить, что программист ответственен за очистку поля base после использования

Теперь отдельно посмотрим колбек на чтение

Напомню, что поле result запроса req содержит число удачно прочитанных символов. Как обычно, вызываем uv_fs_req_cleanup 
для очистки памяти, которая могла быть выделена в ходе выполнения. Вызов uv_fs_req_cleanup не обязательно проводить 
внутри колбэка. Все эти вызовы можно сгруппировать вместе после выполнения операций, например, так

В конце делаем запрос на закрытие uv_fs_close.

Теперь прочитаем большой файл, который не помещается в буфер. Для этого будем проверять результат выполнения. Если 
считалось байт столько, какой и размер буфера, то считываем дальше, увеличивая offset – сдвиг в читаемом файле.

Отметим следующие моменты

Весь код

Это просто – делаем запрос на запись.

Теперь обсудим запрос на запись

Здесь важно правильно указать права – O_CREAT – на создание, если файл ещё не создан, O_APPEND – добавить данные в конец 
(т.е. при нескольких запусках программы будет несколько раз записано одно и то же).

Колбэк на запись почти ничего не делает, он будет вызван тогда, когда данные записались, и после этого сразу же закрывает файл.

Для удаления файла используется функция uv_fs_unlink

Следует указать, что все запросы к файловой системе буду выполнены синхронно в том случае, если в качестве колбэка стоит NULL:

![mail.png](../images/mail.png)

