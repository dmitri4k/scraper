## Указатель как результат функции

В прошлой теме рассматривались такие функции, как calloc, malloc, realloc, которые возвращали в качестве результата указатель. То есть 
функция может не принимать указатели как параметры, но и возвращать указатель. Определение подобной функции выглядит следующим образом:

```
тип *имя_функции (параметры) 
{
	// тело функции
	тип *имя_указателя;
	return  имя_указателя;
}
```

Преимуществом использования указателя как возвращаемого типа является то, что это позволяет получать из функции набор значений, в частности, массив. 
Например, пусть у нас в программе имеются два массива, и мы хотим их сложить с помощью специальной функции:

```
#include <stdio.h>
#include <stdlib.h>
 
int *addArrays(int a[], int b[], int n) 
{
    int *ptr = calloc(n, sizeof(int)); 
 
     for (int i = 0; i < n; i++)
        ptr[i] = a[i] + b[i];
 
     return ptr;
}
 
int main(void)
{
    int a[] = {3,4,5,6,7};
    int b[] = {1,1,1,1,1};
 
    int n = sizeof(a)/sizeof(a[0]);
    int *ptr = addArrays(a, b, n);

    for(int i = 0; i < n; i++)
        printf("%d \t", ptr[i]);

    free(ptr);
    return 0;
}
```

Функция addArrays() для хранения результатов сложения двух массивов выделяет динамическую память, на которую указывает указатель ptr. 
Затем эта динамическая память наполняется результатами сложения соответствующих элементов двух массивов. А возвращаемым значением служит указатель ptr.

В функции main мы можем получить возвращаемый указатель и перебрать все значения из динамической памяти:

```
int *ptr = addArrays(a, b, n);
for(int i = 0; i < n; i++)
    printf("%d \t", ptr[i]);
```

Когда указатель становится не нужен, ранее выделенная динамическая память освобождается с помощью функции free().

Результатом работы программы будет следующий вывод:

```
4	5	6 	7	8
```

Стоит отметить, что указатель, возвращаемый из функции, не должен представлять адрес локальной переменной. Потому что локальная переменная существует 
только во время работы этой функции. Например, как ранее было сказано, через указатель мы можем ссылать на массив. Изменим функцию addArrays:

```
int *addArrays(int a[], int b[], int n) 
{
	int ptr[n];
    for (int i = 0; i < n; i++)
		ptr[i] = a[i] + b[i];

    return ptr;
}
```

Однако мы даже не сможем скомпилировать данный пример, так как массив ptr здесь задан как локальная переменная.

НазадСодержаниеВперед

