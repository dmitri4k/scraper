# Функции

## Определение и описание функций

Если переменные и константы хранят состояние программы, то функции определяют ее действия. По сути функция представляет именованный кусок кода, который можно многократно использовать 

в различных частях программы.

Формальное определение функции выглядит следующим образом:

```
тип имя_функции(параметры)

{

	выполняемые_инструкции

}
```

Первая строка представляет заголовок или сигнатуру функции. Вначале указывается возвращаемый тип функции. Если функция не возвращает никакого значения, то используется тип 

void.

Затем идет имя функции, которое представляет произвольный идентификатор, к которому применяются те же правила, что и к именованию переменных.

После имени функции в круглых скобках идет перечисление параметров. Функция может не иметь параметров, в этом случае указываются пустые скобки.

После заголовка функции в фигурных скобках идет тело функции, которое содержит выполняемые выражения.

В предыдущих статьях уже использовались как минимум две функции. Так, каждая программа на языке Си должна содержать функцию main. Также для вывода строки на консоль применялась функция 

printf(). Теперь определим свою простейшую функцию:

```
#include <stdio.h>

void hello()

{

	printf("Hello!\n");

}

int main(void)

{	

	return 0;

}
```

Кроме стандартной функции main здесь также определена функция hello. Эта функция имеет тип void, то есть 

фактически она ничего не возвращает. Она не имеет никаких параметров, поэтому после названия функции идут пустые круглые скобки. И все, что делает данная функция, - просто 

выводит на консоль строку "Hello!".

Но если мы запустим сейчас программу на выполнение, то никаких строк на консоль не будет выводиться, более того наша функция hello() не будет выполняться..

Для выполнения функции ее необходимо вызвать. Вызов функции осуществляется в форме:

```
имя_функции(аргументы);
```

После имени функции указываются скобки, в которых перечисляются аргументы - значения для параметров функции.

В любой программе должна быть как минимум одна функция, которая имеет фиксированное имя main(). Именно с функции main начинается выполнение. 

Поэтому если мы хотим выполнить функцию hello, то нам надо ее вызвать в функции main.

```
#include <stdio.h>

// определение функции

void hello()

{

	printf("Hello!\n");

}

int main(void)

{	

	hello();	// вызов функции

	hello();	// вызов функции

	return 0;

}
```

В данном случае функция hello вызывается два раза. В этом и состоит прелесть функция: мы можем вынести некоторое общее действие, которое может состоять из нескольких строк, в отдельную функцию и затем вызывать многократно 

в различных местах программы. Поскольку функция hello() не имеет никаких параметров, то в при вызове ей не передается никаких 

аргументов - указываются просто пустые круглые скобки:

```
hello();
```

В итоге программа два раза выведет строку "Hello".

Здесь стоит учесть важный момент - компилятор должен знать о функции до ее вызова. Поэтому вызов функции должен происходить после ее определения, как в случае выше. В некоторых языках это не имеет значение, но в языке Си это играет большую роль. 

И если, к примеру, мы сначала вызовем, а потом определим функцию, то мы можем получить ошибку на этапе компиляции, как в следующем случае:

```
#include <stdio.h>

int main(void)

{

	hello();

	hello();

	return 0;

}

void hello()

{

	printf("Hello!\n");

}
```

Некоторые компиляторы могут скомпилировать данный код, но тем не менее при компиляции сгенерируют предупреждение.

Но есть и другой способ, который заключается в использовании описания функции. Описание функции еще называют прототипом. Формальное определение прототипа 

выглядит следующим образом:

```
тип имя_функции(параметры);
```

Фактически это заголовок функции. То есть для функции hello прототип будет выглядеть следующим образом:

```
void hello();
```

Применим прототип функции:

```
#include <stdio.h>

// описание

void hello(void);

int main(void)

{

	hello();

	hello();

	return 0;

}

// определение

void hello()

{

	printf("Hello!\n");

}
```

В данном случае несмотря на то, что определение функции идет после ее вызова, но так как ее описание идет до вызова, то компилятор уже будет знать 

о функции hello, и никаких проблем в работе программы не возникнет.

