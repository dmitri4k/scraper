## Параметры функции

Функция может принимать параметры. Параметры позволяет передать извне в функцию некоторые данные, настроить ее выполнение. 

Параметры перечисляются в скобках после имени функции имеют следующее определение:

```
тип имя_функции (тип параметр1, тип параметр2,... тип параметрN)
```

Для каждого параметра сначала указывается тип, а затем название параметра. Через запятую определяется следующий параметр.

Например, мы хотим, чтобы функция выводила разные сообщения на консоль. Для этого определим функцию, которая в качестве параметра принимает массив символов:

```
#include <stdio.h>

// функция принимает массив символов

void print_message(char message[])

{

	printf("%s\n", message);

}

int main(void)

{

	print_message("Hello METANIT.COM!");

	print_message("Hello World!");

	print_message("Hello work...");

}
```

Здесь функция print_message() принимает один параметр, который называется message и который имеет тип char[]. Параметр message еще 

называется формальным параметром

В функции main три раза вызываем функцию print_message, передавая ей разные значения - строки "Hello METANIT.COM!", "Hello World!" и "Hello work...". Эти значения еще 

называют аргументами. Таким образом, на консоль будут выведены три строки:

```
Hello METANIT.COM!

Hello World!

Hello work...
```

Прототип функции print_message() выглядел бы следующим образом:

```
void print_message(char[]);
```

Полный пример с прототипом:

```
#include <stdio.h>

// прототип функции print_message

void print_message(char[]);

int main(void)

{

	print_message("Hello METANIT.COM!");

}

// определение функции print_message

void print_message(char message[])

{

	printf("%s\n", message);

}
```

Если необходимо несколько параметров, то они перечисляются через запятую. Например, напишем функцию, которая вычисляет сумму двух чисел:

```
#include <stdio.h>

void sum(int x, int y)

{

	printf("%d + %d = %d \n", x, y,  x + y);

}

int main(void)

{

	sum(1, 2);

	sum(4, 5);

	sum(6, 2);

}
```

Функция sum() принимает два параметра типа int.

В методе main эта функция вызывается три раза, и каждый раз ей передается два разных аргумента для параметров x и y. Соответствие между аргументами 

и параметрами устанавливается по их расположению: первый аргумент передает значение для первого параметра, второй аргумент - для второго параметра и так далее. Консольный вывод программы:

```
1 + 2 = 3

4 + 5 = 9

6 + 2 = 8
```

Прототип функции sum выглядел бы следующим образом:

```
void sum(int, int);
```

Между передаваемыми в функцию аргументами и ее параметрами должно быть соответствие по типу. Если же типы не совпадают, то компилятор пытается автоматически выполнить преобразование типов.

Например, выше использовалась функция void sum(int, int). Если мы передадим в sum значения другого типа, то компилятор будет пытаться привести их 

к типу int:

```
int main(void)

{

	sum(1.4, 2.5);  // передаем значения double

	sum(1.4f, 2.5f);  // передаем значения float

}
```

В обоих случаях фактически функция sum получить числа 1 и 2.

При передаче параметров следует учитывать, то они передаются в функцию по значению. То есть функция не изменяет значения передаваемых аргументов. 

Рассмотрим следующий пример:

```
#include <stdio.h>

void increase(int x)

{

	x = 2 * x;

	printf("Increase func: x = %d \n", x);

}

int main(void)

{

	int a = 25;

	increase(a);

	printf("Main func: a = %d \n", a);

}
```

Функция increase через параметр получает число и увеличивает его в два раза.

В функции main вызываем функцию increase, передавая ей значение переменной a. И после того, как функция increase отработала и изменила значение своего параметра, 

проверяем значение переменной a.

И при выполнении мы увидим, что изменения аргументов в функции increase действуют только в рамках этой функции. Вне ее значение переменной a остается неизменным:

```
Increase func: x = 50

Main func: a = 25
```

Почему так происходит? При компиляции функции для ее параметров выделяются отдельные участки памяти. При этом для параметров типа float формируются 

в памяти объекты типа double, а для параметров типов char и short int - объекты типа 

int.

При вызове функции вычисляются значения аргументов, которые передаются на место параметров. И затем значения аргументов заносятся в участки памяти, 

отведенные для параметров. При этом значения типа float преобразуются 

в объекты типа double, а объекты типов char и short int - в объекты типа 

int.

Если в вызов функции передается переменная, то функция получает копию ее значения. Поэтому все манипуляции со значением параметра внутри функции никак не затронут оригинальную переменную.

После завершения работы функции память, выделенная для параметров, освобождается.

Мы можем в функции изменить значение параметра:

```
void change(int n)

{

    n = n * 2;		// значение параметра изменяется

    printf("n = %d \n", n);

}
```

Однако подобное поведение не всегда желательно. Нередко бывают ситуации, когда надо гарантировать, что параметр сохранит свое значение на протяжении всей работы функции. В этом случае можно объявить 

параметр как константный с помощью ключевого слова const:

```
void change(const int n)

{

    //n = n * 2;	// теперь параметр n нельзя изменить

    int m = n * 2;

    printf("n = %d \n", n);

    printf("m = %d \n", m);

}
```

