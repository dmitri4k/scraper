## Консольный ввод-вывод

При запуске программы на Си автоматически открываются ряд потоков, основными из которых являются следующие:

Стандартный поток ввода stdin

Стандартный поток вывода stdout

Стандартный поток вывода сообщений об ошибках stderr

Стандартный поток ввода stdin по умолчанию соответствует клавиатуре, а потоки stdout и 

stderr - экрану монитора.

Для управления вводом-выводом с помощью этих потоков используются ряд функций:

getchar(): ввод с клавиатуры одного символа

putchar(): вывод на консоль одного символа

fgets(): ввод одной строки

puts() / fputs(): вывод одной строки на консоль

scanf(): ввод с консоли с форматированием данных

sscanf(): ввод с из строки с форматированием данных

printf(): вывод с форматированием данных

Функции printf и scanf уже рассматривались ранее, поэтому посмотрим, как применять остальные функции.

Для ввода и вывода символа применяются функции getchar() и putchar(). Но следует сказать, что на самом деле они 

полноценными функциями не являются, а определены как макросы в заголовочном файле stdio.h:

```
#define getchar()	getc(stdin)

#define putchar(c)	putc((c), stdout)
```

Для вывода отдельного символа на консоль предназначена функция putchar() со следующим прототипом:

```
int putchar(int c);
```

Выводимый символ в виде числового кода передается в putchar в качестве параметра, он же возвращается функцией.

```
#include <stdio.h>

int main(void)

{

	char c = 'A';

	putchar(c);		// Выводим символ A

}
```

Для ввода одного символа с клавиатуры применяется функция getchar(), которая имеет следующий прототип:

```
int getchar(void);
```

В качестве результата функция возвращает числовой код введенного символа.

При использовании функции getchar следует учитывать, что при печати текста посредством клавиатуры 

в буфер операционной системы заносятся коды печатаемых символов, а сами символы отображаются на экране. 

Поучение программой введенного символа из буфера производится с помощью нажатия клавиши Enter.

И если буфер операционной системы не пуст, то при вызове функции getc() она получает очередной символ из буфера. 

Если же буфер пуст, то происходит чтение байта из потока ввода с помощью системной функции, название которой зависит от операционной системы.

При этом при нажатии клавиши Enter, в буфер также помещается код этой клавиши. То есть 

если мы введем один символ и нажмем на Enter, в буфере окажутся два числовых кода - введенного символа и клавиши Enter. И это надо учитывать при работе с 

функцией getchar. В частости, рассмотрим простой, но показательный пример:

```
#include <stdio.h>

int main(void)

{

    printf("1");

	getchar(); // ожидание ввода символа

	printf("2");

	getchar(); // ожидание ввода символа

	printf("3");

	

    return 0;

}
```

Сначала на экран выводится цифра 1, после чего функция getchar ожидает ввода символа. Если после ввода символа мы нажмем Enter, то в буфер будет помещены два числовых кода - введеного символа и 

клавиши Enter. Поэтому при втором вызове getchar эта функция считывает байт из буфера - то есть числовой код клавиши Enter.

Например, введем при первом вызове функции getchar символ "a", а затем Enter:

```
1a

23
```

Но если при каждом вызове getchar мы будем только нажимать клавишу Enter, тогда в буфер будет заноситься только код этой клавиши, и соответственно 

программа будет работать, как и ожидалось:

```
1

2

3
```

Применим функции getchar и putchar для ввода и вывода символов с клавиатуры:

```
#include <stdio.h>

int main(void)

{

    int c;

	

	while((c=getchar())!=EOF)

	{

		putchar(c);

	}

    return 0;

}
```

Функция getchar() считывает числовой код символа, который потом выводится в функции putchar(). Для вывода из программы необходимо ввести комбинацию клавиш 

Ctrl+C.

Для вывода одной строки на консоль предназначена функция puts() со следующим прототипом:

```
int putchar(char *s);
```

В качестве параметра передается указатель на строку, а возвращаемым результатом функции является последний выведенный символ.

При этом функция puts() будет выводить символы переданной строки, пока не дойдет до нулевого символа '\0'. 

Если же выводимый массив символов не содержит этого символа, то результат программы неопределен. Например:

```
#include <stdio.h>

 

int main(void)

{

    puts("Hello World");        // выводим строковый литерал

    char* name = "Hello Metanit.com";

    puts(name);                 // выводим значение переменной

    return 0;

}
```

Консольный вывод:

```
Hello World

Hello Metanit.com
```

Функция fputs() также записывает в поток вывода строку, то есть набор символов, который завершается символом '\0'. При записи строки нулевой символ '\0' не записывается. Она имеет следующий прототип:

```
int fputs(const char *s, FILE *stream);
```

Первый параметр функции - записываемая строка, а второй - указатель на поток вывода. В качестве результата функция возвращает неотрицательное целое число. 

При ошибках в процессе записи возвращается значение EOF.

Применим функцию для записи в стандартный поток вывода, то есть на консоль. В этом случае в качестве второго параметра надо передать значение stdout:

```
#include <stdio.h>

  

int main(void)

{

    fputs("Hello METANIT.COM.\n", stdout);

    return 0;

}
```

Для ввода строки с клавиатуры применяется функция fgets(), которая имеет следующий прототип:

```
char *fgets(char *str, int count, FILE *stream);
```

Параметры функции

char *str: строка, в которую производится считывание.

int count: сколько символов необходимо считывать.

FILE *stream: файловый поток, из которого производится считывание. В качестве потока ввода может выступать и консольный ввод.

Функция fgets() прекращает считывание, когда пользователь нажимает клавишу ENTER, то есть когда в поток добавляется символ перевода строки.

Рассмотрим считывание строки с консоли. Для этого в качестве третьего параметра в функцию передается значение stdin:

```
#include <stdio.h>

#define MAX 15

int main(void)

{

 	char name[MAX];

    printf("Enter name: ");

 	fgets(name, MAX, stdin);

 	printf("Your name: %s\n", name);

	return 0;

}
```

Здесь функция fgets считывает не более 15 символов в строку name, а В реальности функция предложит ввести 14 символов, так как последний символ зарезервирован для нулевого символа '\0'. 

Если будет введено больше символов, то fgets все равно считает не более 15 символов. Таким образом 

функция позволяет проверить количество считываемых символов и поэтому считается безопасной.

Пример работы программы:

```
Enter name: Tom Smith

Your name: Tom Smith
```

Стоит отметить, что функция fgets() возвращает указатель char * - указатель на буфер, в который считаны данные. В реальности это 

тот же самый буфер, который передавался в качестве первого параметра, то есть в примере выше - это массив name. Однако этот результат может нам пригодится для проверки успешности 

выполнения функции - если считывание прошло неудачно, то функция возвращает NULL:

```
#include <stdio.h>

#define MAX 15

int main(void)

{

 	char name[MAX];

    printf("Enter name: ");

 	if(fgets(name, MAX, stdin) != NULL)

	// if(fgets(name, MAX, stdin)) - можно сократить

	{

		printf("Your name: %s\n", name);

	}

 	else

	{

		printf("Critical Error!!!");

	}

	return 0;

}
```

Для эмуляции ошибки можно передать в функцию вторым параметром число 0.

При использовании функции fgets() после функции scanf() мы можем столкнуться с некорректным вводом:

```
#include <stdio.h>

#define N 32

int main(void){

    int age;

    char name[N];

    // считываем возраст в переменную age

    printf("Input age: ");

    scanf("%d", &age);

    // считываем строку в переменну. name

    printf("Input name: ");

    fgets(name, N, stdin);

    // проверяем ввод

    printf("Age: %d\n", age);

    printf("Name: %s\n", name);

}
```

В данном случае сначала с помощью функции scanf() считываем число в переменную age. После этого считываем имя - строку с помощью функции fgets() в 

переменную name. Но посмотрим, какой будет результат работы программы:

```
Input age: 39

Input name: Age: 39Name:
```

В данном случае мы видим, что ввод имени с помощью fgets вроде как пропускается. По крайней мере мы не можем ввести имя, а программа сразу же выводит результат.

Все дело в том, что функция scanf() считывает именно то, что ей предписано - число в виде переменной типа int. Все остальные символы остаются в буфере, в который предварительно 

попадают введенные с клавиатуры символы. Так, после ввода возраста мы нажимаем на клавишу Enter, и в буфер попадает символ "\n", то есть перевод строки. 

И fgets считывает этот символ из буфера, после чего ввод имени завершается. Очевидно, это не то поведение, на которое мы рассчитывали.

Чтобы исправить ситуацию, мы можем использовать различные хаки. Рассмотрим пару из них. Все они сводятся к тому, чтобы вынуть из буфера этот символ перевода строки.

Первый способ - считывание символа с помощью вызова scanf("%*c"):

```
#include <stdio.h>

#define N 32

int main(void){

    int age;

    char name[N];

    // считываем возраст в переменную age

    printf("Input age: ");

    scanf("%d", &age);

    scanf("%*c"); // вытаскиваем символ из буфера

    // считываем строку в переменну. name

    printf("Input name: ");

    fgets(name, N, stdin);

    // проверяем ввод

    printf("Age: %d\n", age);

    printf("Name: %s\n", name);

}
```

Второй способ - мы можем считать символ с помощью getchar():

```
#include <stdio.h>

#define N 32

int main(void){

    int age;

    char name[N];

    // считываем возраст в переменную age

    printf("Input age: ");

    scanf("%d", &age);

    getchar(); // вытаскиваем символ из буфера

    // считываем строку в переменну. name

    printf("Input name: ");

    fgets(name, N, stdin);

    // проверяем ввод

    printf("Age: %d\n", age);

    printf("Name: %s\n", name);

}
```

Результат работы программы:

```
Input age: 39

Input name: Tom

Age: 39

Name: Tom

