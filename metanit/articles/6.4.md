## Массивы структур

Из структур можно создавать массивы также, как массивы других типов. И все форматы определения массива структур будут аналогичны определению массивов других типов:

```
struct person people[10];
```

В данном случае определен массив структур person из 10 элементов.

Используем массив структур в программе:

```
#include <stdio.h>

struct person 

{

	int age;

	char name[20];

};

int main(void)

{

	struct person people[] = { {23, "Tom"}, {32, "Bob"}, {26, "Alice"}, {41, "Sam"}};

	int n = sizeof(people)/sizeof(people[0]);

	for(int i=0; i<n; i++)

	{

		printf("Name:%s \t Age: %d \n", people[i].name, people[i].age);

	}

	return 0;

}
```

В массиве people определено 4 объекта person. При инициализации данные каждой отдельной структуры заключаются во вложенные фигурные скобки:

```
{ {23, "Tom"}, {32, "Bob"}, {26, "Alice"}, {41, "Sam"}}
```

Обращение к элементам массива структур происходит по индексу people[0]. А чтобы обратиться к элементу структуры из массива, 

после индекса указывается имя элемента структуры: people[i].name

Консольный вывод программы:

```
Name: Tom		Age: 23

Name: Bob		Age: 32

Name: Alice		Age: 26

Name: Sam		Age: 41
```

И также как с массивами других типов с массивами структур можно использовать указатели:

```
#include <stdio.h>

struct person 

{

	int age;

	char name[20];

};

int main(void)

{

	struct person people[] = { {23, "Tom"}, {32, "Bob"}, {26, "Alice"}, {41, "Sam"}};

	

	int n = sizeof(people)/sizeof(people[0]);

	

	for(struct person *p=people; p < people+n; p++)

	{

		printf("Name:%s \t Age: %d \n", p->name, p->age);

	}

	return 0;

}
```

Здесь в массиве people те же 4 элемента person. Для их просмотра создан указатель *p, который устанавливается на начало массива people. И в цикле 

получаем элементы структур через этот указатель. После завершения каждой итерации указатель увеличивается на единицу, то есть перемещается в памяти на количество байт, которые занимает одна структура. 

